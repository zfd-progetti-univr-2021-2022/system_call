.TH "/mnt/c/Users/stefa/Desktop/system_call/src/client.h" 3 "Dom 3 Apr 2022" "Version 0.0.1" "SYSTEM_CALL" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/mnt/c/Users/stefa/Desktop/system_call/src/client.h \- Contiene la definizioni di variabili e funzioni specifiche del CLIENT\&.  

.SH SYNOPSIS
.br
.PP
.SS "Funzioni"

.in +1c
.ti -1c
.RI "void \fBSIGINTSignalHandler\fP (int sig)"
.br
.RI "Handler del segnale SIGINT\&. "
.ti -1c
.RI "void \fBSIGUSR1SignalHandler\fP (int sig)"
.br
.RI "Handler del segnale SIGUSR1\&. "
.ti -1c
.RI "void \fBdividi\fP (int fd, char *buf, size_t count, char *filePath, int parte)"
.br
.RI "Divide in 4 parti il contenuto del file da inviare al server\&. "
.ti -1c
.RI "void \fBoperazioni_figlio\fP (char *filePath)"
.br
.RI "Funzione eseguita da ogni Client i (figli di Client 0) per mandare i file al server\&. "
.ti -1c
.RI "int \fBmain\fP (int argc, char *argv[])"
.br
.in -1c
.SH "Descrizione dettagliata"
.PP 
Contiene la definizioni di variabili e funzioni specifiche del CLIENT\&. 


.SH "Documentazione delle funzioni"
.PP 
.SS "void dividi (int fd, char * buf, size_t count, char * filePath, int parte)"

.PP
Divide in 4 parti il contenuto del file da inviare al server\&. 
.PP
\fBParametri:\fP
.RS 4
\fIfd\fP File descriptor del file da inviare 
.br
\fIbuf\fP Buffer in cui memorizzare la porzione del messaggio 
.br
\fIcount\fP Dimensione della porzione di messaggio 
.br
\fIfilePath\fP Percorso del file da suddividere 
.br
\fIparte\fP Numero identificativo della porzione di messaggio 
.RE
.PP

.SS "int main (int argc, char * argv[])"
Memorizza il percorso passato come parametro, gestisce segnali e handler, attende i segnali SIGINT o SIGUSR1\&.
.PP
\fBParametri:\fP
.RS 4
\fIargc\fP Numero argomenti passati da linea di comando (compreso il nome dell'eseguibile) 
.br
\fIargv\fP Array di argomenti passati da linea di comando 
.RE
.PP
\fBRestituisce:\fP
.RS 4
int Exit code dell'intero programma
.RE
.PP
ANNOTAZIONE: Probabilmente bisogna fare un ciclo per aspettare ogni file\&. Per ogni file bisogna attendere le 4 parti e poi scriverle su file in ordine\&.
.PP
terminazione effettuata con SIGINT: Al termine chiudi tutte le IPC\&. 
.SS "void operazioni_figlio (char * filePath)"

.PP
Funzione eseguita da ogni Client i (figli di Client 0) per mandare i file al server\&. 
.PP
\fBDa fare\fP
.RS 4
Aggiungere la sincronizzazione con gli altri client
.RE
.PP
.PP
\fBDa fare\fP
.RS 4
Aggiungere la parte di comunicazione delle quattro parti dei messaggi
.RE
.PP
.PP
\fBWarnings\fP
.RS 4
siccome l'ultima parte del messaggio e' l'unica che puo' essere piu' corta per specifica\&.\&.\&. Cosa bisogna fare in casi in cui non e' possibile garantire questo vincolo? Esempio: 2 caratteri possono essere divisi in:
.IP "\(bu" 2
caratteri per parte: 1 1 0 0
.IP "\(bu" 2
oppure: 2 0 0 0 
.br
 Lo stesso problema si pone per 1, 2, 5, 6, 9, 10, \&.\&.\&. caratteri\&. 
.br
 Non posso garantire come ad esempio nel caso di 3 caratteri che sono l'ultimo numero sia inferiore: Esempio di suddivisione di 3 caratteri: 1 1 1 0\&. L'ultimo, come per specifica, e' l'unico di dimensione inferiore
.PP
.RE
.PP
.PP
\fBParametri:\fP
.RS 4
\fIfilePath\fP Percorso del file che il client deve suddividere e mandare al server\&. 
.RE
.PP

.SS "void SIGINTSignalHandler (int sig)"

.PP
Handler del segnale SIGINT\&. 
.PP
\fBDa fare\fP
.RS 4
Gestire la parte di comunicazione con il server\&.
.RE
.PP
.PP
\fBDa fare\fP
.RS 4
Potrebbe essere necessario ottimizzare l'uso dello HEAP nel client 0\&. Attualmente la dimensione massima occupata dal client e': $$100 file * dim\&. path + 100 file * dim\&. pointer$$\&. Assumento dim\&. path massima = 250 caratteri e dim\&. pointer 4 byte (32 bit): $$100 * 250 + 100 * 4 = 25400$$ Quindi solo lato client si occupano 25 KByte\&. Altro problema: ogni client i eredita la lista creando al massimo altre 100 liste concatenate? In quel caso si occuperebbero: $$25 + 100 * 25 = 2525$$ Ovvero 2525 KB, circa 2\&.5 MB\&.
.RE
.PP
.PP
\fBWarnings\fP
.RS 4
Per ottimizzare l'uso dello HEAP nel client 0 si potrebbe prima cercare e contare quanti file sono presenti senza creare una lista concatenata e poi ricercare i file e man mano che si trovano file send_me si puo' creare il processo figlio per inviare il file\&. Per fare questo BISOGNA sapere se il numero di file puo' cambiare durante l'esecuzione del programma: se trovo 3 file e dopo un file viene cancellato cosa succede? 
.br
 NOTA: questo problema puo' esserci anche nella situazione attuale\&.\&.\&.
.RE
.PP
.PP
\fBWarnings\fP
.RS 4
Il client 0 deve attendere i processi figlio? La specifica indica solo che bisogna attendere il messaggio di fine dal server\&.\&.\&. Probabilmente prima bisogna attendere il messaggio di fine e poi aspettare che tutti i figlio terminino (prima di liberare la lista dei file e)\&.
.RE
.PP
.PP
\fBWarnings\fP
.RS 4
Il percorso passato al client deve essere assoluto o puo' essere relativo? Se si passa un percorso relativo chdir() fallira' alla seconda esecuzione\&. 
.br
 SOLUZIONE: si potrebbe usare un altro chdir() a fine funzione per tornare al percorso di esecuzione iniziale anticipando il chdir() successivo\&.
.RE
.PP
.PP
Esegue tutte le funzionalita' principali del client\&.
.PP
\fBParametri:\fP
.RS 4
\fIsig\fP Valore intero corrispondente a SIGINT 
.RE
.PP

.SS "void SIGUSR1SignalHandler (int sig)"

.PP
Handler del segnale SIGUSR1\&. 
.PP
\fBDa fare\fP
.RS 4
Gestire la chiusura delle risorse\&. Potrebbe non essere necessario: dipende dalla implementazione delle altre funzioni\&.
.RE
.PP
.PP
Termina il processo del client 0\&.
.PP
\fBParametri:\fP
.RS 4
\fIsig\fP Valore intero corrispondente a SIGUSR1 
.RE
.PP

.SH "Autore"
.PP 
Generato automaticamente da Doxygen per SYSTEM_CALL a partire dal codice sorgente\&.
