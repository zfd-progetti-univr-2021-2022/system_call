.TH "/mnt/c/Users/stefa/Desktop/system_call/src/client.c" 3 "Sab 23 Apr 2022" "Version 0.0.1" "SYSTEM_CALL" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/mnt/c/Users/stefa/Desktop/system_call/src/client.c \- Contiene l'implementazione del client\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <stdio\&.h>\fP
.br
\fC#include <stdbool\&.h>\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include <signal\&.h>\fP
.br
\fC#include <dirent\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <fcntl\&.h>\fP
.br
\fC#include <sys/stat\&.h>\fP
.br
\fC#include <sys/wait\&.h>\fP
.br
\fC#include <sys/msg\&.h>\fP
.br
\fC#include 'defines\&.h'\fP
.br
\fC#include 'err_exit\&.h'\fP
.br
\fC#include 'signals\&.h'\fP
.br
\fC#include 'files\&.h'\fP
.br
\fC#include 'client\&.h'\fP
.br
\fC#include 'semaphore\&.h'\fP
.br
\fC#include 'shared_memory\&.h'\fP
.br
\fC#include 'fifo\&.h'\fP
.br
\fC#include 'debug\&.h'\fP
.br

.SS "Funzioni"

.in +1c
.ti -1c
.RI "char * \fBint_to_string\fP (int value)"
.br
.ti -1c
.RI "bool \fBstrEquals\fP (char *a, char *b)"
.br
.ti -1c
.RI "void \fBSIGINTSignalHandler\fP (int sig)"
.br
.RI "Handler del segnale SIGINT\&. "
.ti -1c
.RI "void \fBSIGUSR1SignalHandler\fP (int sig)"
.br
.RI "Handler del segnale SIGUSR1\&. "
.ti -1c
.RI "void \fBdividi\fP (int fd, char *buf, size_t count, char *filePath, int parte)"
.br
.RI "Divide in 4 parti il contenuto del file da inviare al server\&. "
.ti -1c
.RI "void \fBoperazioni_figlio\fP (char *filePath)"
.br
.RI "Funzione eseguita da ogni Client i (figli di Client 0) per mandare i file al server\&. "
.ti -1c
.RI "int \fBmain\fP (int argc, char *argv[])"
.br
.in -1c
.SS "Variabili"

.in +1c
.ti -1c
.RI "int \fBfifo1_fd\fP = \-1"
.br
.RI "file descriptor prima fifo "
.ti -1c
.RI "int \fBfifo2_fd\fP = \-1"
.br
.RI "file descriptor seconda fifo "
.ti -1c
.RI "int \fBmsqid\fP = \-1"
.br
.RI "id coda dei messaggi "
.ti -1c
.RI "int \fBsemid\fP = \-1"
.br
.RI "id set di semafori "
.ti -1c
.RI "int \fBshmid\fP = \-1"
.br
.RI "id memoria condivisa messaggi "
.ti -1c
.RI "\fBmsg_t\fP * \fBshm_ptr\fP = NULL"
.br
.RI "puntatore memoria condivisa messaggi "
.ti -1c
.RI "int \fBshm_check_id\fP = \-1"
.br
.RI "id memoria condivisa flag lettura/scrittura messaggi "
.ti -1c
.RI "int * \fBshm_check_ptr\fP = NULL"
.br
.RI "puntatore memoria condivisa flag lettura/scrittura messaggi "
.ti -1c
.RI "char \fBEXECUTABLE_DIR\fP [\fBBUFFER_SZ\fP]"
.br
.RI "Percorso cartella eseguibile\&. "
.ti -1c
.RI "char * \fBsearchPath\fP = NULL"
.br
.RI "contiene percorso passato come parametro "
.in -1c
.SH "Descrizione dettagliata"
.PP 
Contiene l'implementazione del client\&. 


.PP
\fBDa fare\fP
.RS 4
Completare l'implementazione delle funzioni\&. 
.PP
Rimuovere printf di debug o gestirle tramite flag di compilazione\&. 
.PP
Spostare la funzione \fBdividi()\fP ? (una opzione e' metterla in \fBfiles\&.c\fP)
.RE
.PP
.PP
\fBWarnings\fP
.RS 4
La specifica non richiede la documentazione\&. E' richiesta?
.RE
.PP
.PP
\fBWarnings\fP
.RS 4
I percorsi dei file hanno dimensione massima?
.RE
.PP
.PP
\fBWarnings\fP
.RS 4
I caratteri nei file di testo in input ai client sono ASCII? Sono tutti da 1 byte? Bisogna gestire lettere accentate, \&.\&.\&.? 
.RE
.PP

.SH "Documentazione delle funzioni"
.PP 
.SS "void dividi (int fd, char * buf, size_t count, char * filePath, int parte)"

.PP
Divide in 4 parti il contenuto del file da inviare al server\&. 
.PP
\fBParametri:\fP
.RS 4
\fIfd\fP File descriptor del file da inviare 
.br
\fIbuf\fP Buffer in cui memorizzare la porzione del messaggio 
.br
\fIcount\fP Dimensione della porzione di messaggio 
.br
\fIfilePath\fP Percorso del file da suddividere 
.br
\fIparte\fP Numero identificativo della porzione di messaggio 
.RE
.PP

.SS "char* int_to_string (int value)"
Converte un intero in stringa\&.
.PP
\fBParametri:\fP
.RS 4
\fIvalue\fP Valore intero da convertire in stringa 
.RE
.PP
\fBRestituisce:\fP
.RS 4
char* Stringa contenente il valore 
.RE
.PP
.RS 4
E' necessaria la free() dopo aver terminato l'uso della stringa\&.
.RE
.PP

.SS "int main (int argc, char * argv[])"
Memorizza il percorso passato come parametro, gestisce segnali e handler, attende i segnali SIGINT o SIGUSR1\&.
.PP
\fBParametri:\fP
.RS 4
\fIargc\fP Numero argomenti passati da linea di comando (compreso il nome dell'eseguibile) 
.br
\fIargv\fP Array di argomenti passati da linea di comando 
.RE
.PP
\fBRestituisce:\fP
.RS 4
int Exit code dell'intero programma 
.RE
.PP

.SS "void operazioni_figlio (char * filePath)"

.PP
Funzione eseguita da ogni Client i (figli di Client 0) per mandare i file al server\&. 
.PP
\fBDa fare\fP
.RS 4
Aggiungere la sincronizzazione con gli altri client
.RE
.PP
.PP
\fBDa fare\fP
.RS 4
Aggiungere la parte di comunicazione delle quattro parti dei messaggi
.RE
.PP
.PP
\fBWarnings\fP
.RS 4
siccome l'ultima parte del messaggio e' l'unica che puo' essere piu' corta per specifica\&.\&.\&. Cosa bisogna fare in casi in cui non e' possibile garantire questo vincolo? Esempio: 2 caratteri possono essere divisi in:
.IP "\(bu" 2
caratteri per parte: 1 1 0 0
.IP "\(bu" 2
oppure: 2 0 0 0 
.br
 Lo stesso problema si pone per 1, 2, 5, 6, 9, 10, \&.\&.\&. caratteri\&. 
.br
 Non posso garantire come ad esempio nel caso di 3 caratteri che sono l'ultimo numero sia inferiore: Esempio di suddivisione di 3 caratteri: 1 1 1 0\&. L'ultimo, come per specifica, e' l'unico di dimensione inferiore
.PP
.RE
.PP
.PP
\fBParametri:\fP
.RS 4
\fIfilePath\fP Percorso del file che il client deve suddividere e mandare al server\&. 
.RE
.PP

.SS "void SIGINTSignalHandler (int sig)"

.PP
Handler del segnale SIGINT\&. 
.PP
\fBDa fare\fP
.RS 4
Gestire la parte di comunicazione con il server\&.
.RE
.PP
.PP
\fBDa fare\fP
.RS 4
Potrebbe essere necessario ottimizzare l'uso dello HEAP nel client 0\&. Attualmente la dimensione massima occupata dal client e': $$100 file * dim\&. path + 100 file * dim\&. pointer$$\&. Assumento dim\&. path massima = 250 caratteri e dim\&. pointer 4 byte (32 bit): $$100 * 250 + 100 * 4 = 25400$$ Quindi solo lato client si occupano 25 KByte\&. Altro problema: ogni client i eredita la lista creando al massimo altre 100 liste concatenate? In quel caso si occuperebbero: $$25 + 100 * 25 = 2525$$ Ovvero 2525 KB, circa 2\&.5 MB\&.
.RE
.PP
.PP
\fBWarnings\fP
.RS 4
Per ottimizzare l'uso dello HEAP nel client 0 si potrebbe prima cercare e contare quanti file sono presenti senza creare una lista concatenata e poi ricercare i file e man mano che si trovano file send_me si puo' creare il processo figlio per inviare il file\&. Per fare questo BISOGNA sapere se il numero di file puo' cambiare durante l'esecuzione del programma: se trovo 3 file e dopo un file viene cancellato cosa succede? 
.br
 NOTA: questo problema puo' esserci anche nella situazione attuale\&.\&.\&.
.RE
.PP
.PP
\fBWarnings\fP
.RS 4
Il client 0 deve attendere i processi figlio? La specifica indica solo che bisogna attendere il messaggio di fine dal server\&.\&.\&. Probabilmente prima bisogna attendere il messaggio di fine e poi aspettare che tutti i figlio terminino (prima di liberare la lista dei file e)\&.
.RE
.PP
.PP
\fBWarnings\fP
.RS 4
Il percorso passato al client deve essere assoluto o puo' essere relativo? Se si passa un percorso relativo chdir() fallira' alla seconda esecuzione\&. 
.br
 SOLUZIONE: si potrebbe usare un altro chdir() a fine funzione per tornare al percorso di esecuzione iniziale anticipando il chdir() successivo\&.
.RE
.PP
.PP
Esegue tutte le funzionalita' principali del client\&.
.PP
\fBParametri:\fP
.RS 4
\fIsig\fP Valore intero corrispondente a SIGINT 
.RE
.PP

.SS "void SIGUSR1SignalHandler (int sig)"

.PP
Handler del segnale SIGUSR1\&. 
.PP
\fBDa fare\fP
.RS 4
Gestire la chiusura delle risorse\&. Potrebbe non essere necessario: dipende dalla implementazione delle altre funzioni\&.
.RE
.PP
.PP
Termina il processo del client 0\&.
.PP
\fBParametri:\fP
.RS 4
\fIsig\fP Valore intero corrispondente a SIGUSR1 
.RE
.PP

.SS "bool strEquals (char * a, char * b)"
Restituisce vero se due stringhe sono uguali
.PP
\fBParametri:\fP
.RS 4
\fIa\fP Stringa da confrontare 
.br
\fIb\fP Stringa da confrontare 
.RE
.PP
\fBRestituisce:\fP
.RS 4
true a e b sono uguali 
.PP
false a e b sono diverse 
.RE
.PP

.SH "Autore"
.PP 
Generato automaticamente da Doxygen per SYSTEM_CALL a partire dal codice sorgente\&.
